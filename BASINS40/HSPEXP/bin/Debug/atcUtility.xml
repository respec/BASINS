<?xml version="1.0"?>
<doc>
<assembly>
<name>
atcUtility
</name>
</assembly>
<members>
<member name="T:atcUtility.modDate.atcTimeUnit">
	<summary>Standard timeseries time units</summary>
</member><member name="T:atcUtility.modDate.atcTran">
	<summary>Standard timeseries transformations</summary>
</member><member name="F:atcUtility.modDate.SecondsPerDay">
	<summary>Number of seconds in a day</summary>
</member><member name="F:atcUtility.modDate.JulianHour">
	<summary>One hour as fraction of a day</summary>
</member><member name="F:atcUtility.modDate.JulianMinute">
	<summary>One minute as fraction of a day</summary>
</member><member name="F:atcUtility.modDate.JulianSecond">
	<summary>One second as fraction of a day</summary>
</member><member name="F:atcUtility.modDate.JulianHalfSecond">
	<summary>Half a second as fraction of a day</summary>
</member><member name="F:atcUtility.modDate.JulianMillisecond">
	<summary>One millisecond as fraction of a day</summary>
</member><member name="F:atcUtility.modDate.JulianMonth">
	<summary>Average length of a month as number of days</summary>
	<remarks>When doing math on months and years, it is more accurate to use subroutines Timdif, Timadd, TimAddJ</remarks>
</member><member name="F:atcUtility.modDate.JulianYear">
	<summary>Average length of a year as a number of days</summary>
	<remarks>When doing math on months and years, it is more accurate to use subroutines Timdif, Timadd, TimAddJ</remarks>
</member><member name="F:atcUtility.modDate.MonthName3">
	<summary>Three-letter month names</summary>
</member><member name="M:atcUtility.modDate.Date2J(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 convert a date array to a modfied Julian date (MJD)
 </summary>
	<param name="aYr"></param>
	<param name="aMo"></param>
	<param name="aDy"></param>
	<param name="aHr"></param>
	<param name="aMn"></param>
	<param name="aSc"></param>
	<returns>modified Julian date</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.Date2J(System.Int32[])">
	<summary>convert a date array to a modfied Julian date (MJD)</summary>
	<param name="aDate">date array to convert</param>
	<returns>modified Julian date</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.HMS2J(System.Int32,System.Int32,System.Int32)">
	<summary>convert an hour, minute, and second to a modifed Julian date (MJD)</summary>
	<param name="aHr">hour to convert</param>
	<param name="aMi">minute to convert</param>
	<param name="aSc">second to convert</param>
	<returns>modified Julian date</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.J2DateRoundup(System.Double,atcUtility.modDate.atcTimeUnit,System.Int32[])">
	<summary>
 Round up dates to given time unit
 </summary>
	<param name="aJDate"></param>
	<param name="aTU"></param>
	<param name="aDate"></param>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.J2DateRounddown(System.Double,atcUtility.modDate.atcTimeUnit,System.Int32[]@)">
	<summary>
 Round down dates to given time unit
 </summary>
	<param name="aJDate"></param>
	<param name="aTU"></param>
	<param name="aDate"></param>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.J2Date(System.Double,System.Int32[]@)">
	<summary>
 Convert a modified Julian date (MJD) As Double to an array of integers
 representing year, month, day, hour, minute, second
 </summary>
	<param name="aJd">modfied Julian date to convert</param>
	<param name="aDate">output array containing year, month, day, hour, minute, second</param>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.J2HMS(System.Double,System.Int32@,System.Int32@,System.Int32@,System.Double@)">
	<summary>
 convert the time portion of a modfied Julian date to its component parts
 </summary>
	<param name="aJd">MJD to convert</param>
	<param name="aHr">hour portion of MJD</param>
	<param name="aMi">minute portion of MJD</param>
	<param name="aSc">second portion of MJD</param>
	<param name="aFrac">fraction of a second</param>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.INVMJD(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
	<summary>
 invert modified Julian date as computed by function MJD (from DelbertDFranz)
 </summary>
	<param name="aMJD">value of modified julian date date number to invert</param>
	<param name="aYr">calendar year</param>
	<param name="aMn">number of month(1-12)</param>
	<param name="aDy">day in the month</param>
	<remarks>Developed from information given in: "Astronomical Formulae for Calculators", Jean Meeus, published by Willmann-Bell.</remarks>
</member><member name="M:atcUtility.modDate.MJD(System.Int32,System.Int32,System.Int32)">
	<summary>
 Compute modified julian date for any date with a year greater than 1582 (from DelbertDFranz)
 </summary>
	<param name="aYr">calendar year</param>
	<param name="aMn">number of month(1-12)</param>
	<param name="aDy">day in the month</param>
	<returns></returns>
	<remarks>
 We take the resulting date to represent the elapsed time from 
 some point in the past to the first instant of the given day. 
 The date must be later than Nov. 17, 1858 for MJD to be 
 a positive number.  Thus for use in FEQ the year must be 1859 or greater. 
 This routine and INVMJD have been checked by DDF for every day from 1860 through the year 25000. 
 Developed from information given in: "Astronomical Formulae 
 for Calculators', Jean Meeus, published by Willmann-Bell.
</remarks>
</member><member name="M:atcUtility.modDate.Jday(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 convert a date array to a modfied Julian date (MJD)
 </summary>
	<param name="aYr"></param>
	<param name="aMo"></param>
	<param name="aDy"></param>
	<param name="aHr"></param>
	<param name="aMn"></param>
	<param name="aSc"></param>
	<returns>modified Julian date</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.JDateIntrvl(System.Double)">
	<summary>
 determines the date interval (6-second thru 1-year) of a modfied Julian date
 </summary>
	<param name="aJd">MJD to determine interval of</param>
	<returns>date interval (6 second, 5 minute, 4 hour, 3 day, 2 month, 1 year</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.DateIntrvl(System.Int32[])">
	<summary>
 determines the date interval (6-second thru 1-year) of a date array
 </summary>
	<param name="aDate">date array to determine interval of</param>
	<returns>date interval (6 second, 5 minute, 4 hour, 3 day, 2 month, 1 year</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.DayMon(System.Int32,System.Int32)">
	<summary>
 return the number of days in the given month for the given 
 year, with leap year taken into account.  
 </summary>
	<param name="aYr">year, valid range is 1 - 9999</param>
	<param name="aMo">month, valid range is 1 - 12</param>
	<returns>number of days</returns>
	<remarks>
 For an invalid month, -1 is returned. 
 For an invalid year and a valid month, the correct number of days is returned, with February = 28.
 </remarks>
</member><member name="M:atcUtility.modDate.AddUniqueDate(System.Double,System.Double[]@,System.Int32[]@)">
	<summary>
 adds a unique MJD date to an array of dates if it is not already there
 </summary>
	<param name="aJdate">MJD date to try to add</param>
	<param name="aJdateExisting">array of current dates</param>
	<param name="aJDateExistingInterval">array of date intervals corresponding to dates in ja</param>
	<returns>true if date added, false if date was already in array</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.DumpDate(System.Double)">
	<summary>
 convert a modfied Julian date to a string
 </summary>
	<param name="aDateJ">date to convert</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.timcnv(System.Int32[]@)">
	<summary>
 Convert a date that uses the midnight convention of 00:00
 to the convention 24:00.  For example, 1982/10/01 00:00:00
 would be converted to the date 1982/09/30 24:00:00.
 </summary>
	<param name="d"></param>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.TimAddJ(System.Double,atcUtility.modDate.atcTimeUnit,System.Int32,System.Int32)">
	<summary>
 Add (or subtract) specified amount of time to specified date
 </summary>
	<param name="aStartDate">starting date</param>
	<param name="aTimeUnits">time units for add (1-sec,2-min,3-hour,4-day,5-mon,6-year</param>
	<param name="aTimeStep">time step for add</param>
	<param name="aNumValues">number of values to add</param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modDate.TIMADD(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32[]@)">
	<summary>
 Add NVALS time steps to first date to compute second date.
 </summary>
	<param name="DATE1">starting date</param>
	<param name="TCODE">time units
              1 - second          5 - month
              2 - minute          6 - year
              3 - hour            7 - century
              4 - Day
 </param>
	<param name="TSTEP">number of TCODE units in one step, for example 10 if dealing with 10-minute data</param>
	<param name="NVALS">number of (TCODE * TSTEP) time intervals to add</param>
	<param name="DATE2">result of adding (TCODE * TSTEP * NVALS) to DATE1</param>
	<remarks>uses TIMADDJ if NVALS is less than zero</remarks>
</member><member name="M:atcUtility.modDate.CalcTimeUnitStep(System.Double,System.Double,atcUtility.modDate.atcTimeUnit@,System.Int32@)">
	<summary>
 Calculate Time Unit and Time Step between two dates
 </summary>
	<param name="aSJDate">Starting Julian Date</param>
	<param name="aEJDate">Ending Julian Date</param>
	<param name="aTimeUnit">ByRef: returns time unit of difference between dates</param>
	<param name="aTimeStep">ByRef: returns number of steps of time unit between dates</param>
</member><member name="M:atcUtility.modDate.CalcInterval(atcUtility.modDate.atcTimeUnit,System.Int32)">
	<summary>
 Calculate Julian interval represented by the given number of time steps of the given interval
 </summary>
	<param name="aTimeUnit">atcTimeUnit other than Day, Hour, Minute, or Second will return NaN.</param>
	<param name="aTimeStep">Number of time steps. Usually 1 but can for example be 15 for 15-minute data. or 7 for weekly.</param>
	<returns>Number of days represented by aTimeStep * aTimeUnit</returns>
	<remarks>Only time units of days or less are constant interval. Months, Years, and Centuries are not all the same length</remarks>
</member><member name="T:atcUtility.modDate">
	<summary>General date utility subroutines and functions</summary>
	<remarks>Copyright 2001-6 AQUA TERRA Consultants - Royalty-free use permitted under open source license </remarks>
</member><member name="F:atcUtility.atcDateFormat.Midnight24">
	<summary>
 Midnight will be formatted as 24:00 on the previous day if true, will be formatted as 00:00 on the next day if false
 </summary>
	<remarks>default = True</remarks>
</member><member name="P:atcUtility.atcTableFixedStreaming.FieldStart(System.Int32)">
	<summary>
 Character position where the field starts
 </summary>
	<param name="aFieldNumber">Number of field (one to NumFields)</param>
	<value></value>
	<returns>Character position &gt;= 1</returns>
	<remarks>Returns zero if field does not exist</remarks>
</member><member name="M:atcUtility.atcTableDBF.Merge(atcUtility.atcTableDBF,System.String[],System.Int32,System.Collections.ArrayList)">
	<summary>
 Merge records from dbf2Add into this dbf
 </summary>
	<param name="aAddFrom"></param>
	<param name="aKeyFieldNames">Names of fields that together define a unique field. 
 If blank, no duplicate checking will occur.
 If Nothing or = "**ALL**" then the entire record will be used as a key</param>
	<param name="aDuplicateAction">dictates handling of duplicate records as follows:
 0 - do not check for duplicates, just add all new records
 1 - keep existing instance and discard duplicates from dbf being added
 2 - replace existing instance with duplicates from dbf being added</param>
	<param name="aAddedIndexes">Indexes from aAddFrom of items merged are added to aAddedIndexes if provided</param>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTableDBF.findBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
	<summary>
 Search for the set of bytes in aFindThis starting at index aThisFirstByte for aFindNumBytes
 Search through aSearchIn starting at aSearchStart and advancing aSearchStride bytes.
 </summary>
	<param name="aFindThis">Sequence of bytes to find</param>
	<param name="aFindFirstByte">First position in aFindThis to include in search</param>
	<param name="aFindNumBytes">Number of bytes in aFindThis to include in search</param>
	<param name="aSearchIn">Array to search</param>
	<param name="aSearchStart">Index in aSearchIn to start search</param>
	<param name="aSearchStride">Record length in aSearchIn, move this many bytes from aSearchStart to search for next possible match</param>
	<param name="aSearchStop">End the search when we reach this position in aSearchIn</param>
	<param name="aFieldLength">Search this section of each record for aFindThis, skipping zero or space padding. If zero, only check for value that starts exactly at aSearchStart [plus stride * n]</param>
	<returns>
 Number of times the pattern was searched for if found
 0 = pattern was not found
 1 = pattern was found in first place searched
 n = pattern was found (n-1) strides after first place searched
 </returns>
	<remarks>
 Example:
 findBytes(aFindThis = {0, 1, 2, 3}, 
           aFindFirstByte = 1,
           aFindNumBytes = 2,
           aSearchIn = { 0, 0, 1, 2, 4, 1, 2, 0, 0},
           aSearchStart = 1,
           aSearchStride = 4)
 searches for the pattern {1, 2} (the two bytes starting at 1 of aFindThis)
 does not match at the first comparison with bytes {0, 1} in aSearchIn
 (does not match first instance of {1, 2} in aSearchIn because search strides past)
 strides 4, matches {1, 2} after the 4, and returns 2 because it was found on the second comparison
 </remarks>
</member><member name="M:atcUtility.atcTableDBF.findAllNew(atcUtility.atcTableDBF,System.Int32)">
	<summary>
 Find records in aOtherTable that do not match any record in this table
 </summary>
	<param name="aOtherTable">Table to search for new records</param>
	<param name="aField">Optional key field to search. If not specified, entire record will be compared.</param>
	<returns>ArrayList of indexes of new records found in aOtherTable</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modString.Assign(System.Int32@,System.Int32)">
	<summary>
 Assign expression to result and return result
 </summary>
	<param name="aResult">output value of expression</param>
	<param name="aExpression">input value of expression</param>
	<returns>output value of expression</returns>
	<remarks>use this like this 
    While Assign(variable,expression) &gt; 0
       'use variable as needed
    End While
 </remarks>
</member><member name="M:atcUtility.modString.SignificantDigits(System.Double,System.Int32)">
	<summary>
 Round a double-precision number to the specified number of significant digits.
 </summary>
	<param name="aValue">Double-precision number to be formatted</param>
	<param name="aDigits">Number of significant digits</param>
	<returns>aValue rounded to aDigits significant digits.</returns>
	<remarks>Example: Signif(1.23456, 3) =  1.23</remarks>
</member><member name="M:atcUtility.modString.DecimalAlign(System.String[]@,System.Boolean@,System.Boolean@,System.Int32@)">
	<summary>
 Reformat an array of floating point numbers around location of decimal place.
 </summary>
	<param name="aNumericStrings">floating point numbers as strings</param>
	<param name="PadLeft">False to disable adding spaces left of numbers</param>
	<param name="PadRight">False to disable adding spaces right of numbers</param>
	<param name="MinWidth">Minimum width of resulting strings</param>
	<remarks>aNumericStrings is both an input and output argument</remarks>
</member><member name="M:atcUtility.modString.IsInteger(System.String@)">
	<summary>
 Checks to see whether string argument is an integer.
 </summary>
	<param name="aStr">String to be checked for integer status</param>
	<returns>True if each character in string is in range [0-9]</returns>
	<remarks>
 Example: IsInteger(12345) = True
 Example: IsInteger(123.45) = False
 </remarks>
</member><member name="M:atcUtility.modString.IsAlpha(System.String@)">
	<summary>
 Checks to see whether incoming string is entirely alphabetic.
 </summary>
	<param name="aStr">String to be checked for alphabetic status</param>
	<returns>True if input parameter istr contains only [A-Z] or [a-z]</returns>
	<remarks>
 Example: IsAlpha(abcde) = True
 Example: IsAlpha(abc123) = False
 </remarks>
</member><member name="M:atcUtility.modString.IsAlphaNumeric(System.String@)">
	<summary>
 Checks to see whether incoming string is entirely alphanumeric.
 </summary>
	<param name="aStr">String to be checked for alphabetic status</param>
	<returns>True if input parameter istr contains only [A-Z] or [a-z] or [0-9]</returns>
	<remarks>
 Example: IsAlpha(abcde) = True
 Example: IsAlpha(abc123) = True
 Example: IsAlpha(!#?$) = False
 </remarks>
</member><member name="M:atcUtility.modString.ByteIsPrintable(System.Byte@)">
	<summary>
 Checks to see whether incoming byte is printable.
 </summary>
	<param name="aByte">Byte to be checked for printable status</param>
	<returns>True if argument is ASCII code 9, 10, 12, 13, 32 - 126</returns>
	<remarks>
 Example: ByteIsPrintable(44) = True
 Example: ByteIsPrintable(7) = False
 </remarks>
</member><member name="M:atcUtility.modString.Rndlow(System.Double@)">
	<summary>
 Sets values less than 1.0E-19 to 0.0 for the plotting routines for bug in DISSPLA/PR1ME. 
 Otherwise returns values rounded to lower magnitude.
 </summary>
	<param name="aX">Single-precision value</param>
	<returns>Incoming value, rounded to 0.0 if less than 1.0E-19.</returns>
	<remarks>Example: Rndlow(1.0E-20) = 0, Rndlow(11000) = 10000</remarks>
</member><member name="M:atcUtility.modString.SafeSubstring(System.String,System.Int32,System.Int32)">
	<summary>
 Like String.Substring but gracefully return an empty or shorter string when it would have thrown an exception
 </summary>
	<param name="aSourceString">String to get substring of</param>
	<param name="aStartIndex">Zero-based start position of substring</param>
	<param name="aLength">Length of substring</param>
	<remarks>Why could they not have implemented String.Substring more like this?</remarks>
</member><member name="M:atcUtility.modString.SafeSubstring(System.String,System.Int32)">
	<summary>
 Like String.Substring but gracefully return an empty or shorter string when it would have thrown an exception
 </summary>
	<param name="aSourceString">String to get substring of</param>
	<param name="aStartIndex">Zero-based start position of substring</param>
	<remarks>Why could they not have implemented String.Substring more like this?</remarks>
</member><member name="M:atcUtility.modString.StrFindBlock(System.String,System.String,System.String,System.Int32)">
	<summary>
 Find a block of text between two known strings
 </summary>
	<param name="aSource">Text to search through</param>
	<param name="aStartsWith">String that indicates block to find is about to start</param>
	<param name="aEndsWith">String that indicates block to find has ended</param>
	<param name="aStartIndex">Optional offset within aSource to start searching</param>
	<returns>Block of text that was found between aStartsWith and aEndsWith</returns>
	<remarks>Returned string does not include aStartsWith and aEndsWith. 
 Empty string is returned if aStartsWith or aEndsWith is not found.</remarks>
</member><member name="M:atcUtility.modString.StrReplaceBlock(System.String,System.String,System.String,System.String,System.Int32)">
	<summary>
 Replace a block of text between two known strings
 </summary>
	<param name="aSource">Text to search through</param>
	<param name="aStartsWith">String that indicates beginning of block to find</param>
	<param name="aEndsWith">String that indicates end of block to find</param>
	<param name="aReplaceWith">String to replace block that is found</param>
	<param name="aStartIndex">Optional offset within aSource to start searching</param>
	<returns>aSource where block of text that was found between aStartsWith and aEndsWith is replaced by aReplaceWith</returns>
	<remarks>Returned string includes aStartsWith and aEndsWith. 
 aSource is returned unchanged if aStartsWith or aEndsWith is not found.</remarks>
</member><member name="M:atcUtility.modString.CountString(System.String@,System.String@)">
	<summary>
 Count how many times aFind occurs in aSource
 </summary>
	<param name="aSource">String to search through</param>
	<param name="aFind">String to search for</param>
	<returns>number of occurences of aFind in aSource</returns>
	<remarks>Capitalization matters. To count while ignoring capitalization, call with .ToUpper for both arguments.</remarks>
</member><member name="M:atcUtility.modString.ReplaceRepeats(System.String,System.String)">
	<summary>
 Replace multiple adjacent instances of aReplace with just one.
 </summary>
	<param name="aSource">Search through this string</param>
	<param name="aReplace">Search for repeating instances of this string and eliminate repeats</param>
	<returns>aSource without any instances of aReplace next to another aReplace</returns>
	<remarks>For example in space-delimited files that delimit with one or more spaces, change to delimited with just one space</remarks>
</member><member name="M:atcUtility.modString.Byte2String(System.Byte[]@,System.Int32@,System.Int32@)">
	<summary>
 Convert ASCII bytes in an array into a string
 </summary>
	<param name="Byt">Array of bytes</param>
	<param name="StartAt">Index in Byt of first character of string</param>
	<param name="Length">Length of string (number of bytes to read)</param>
	<returns>String containing .Net two-byte version of each one-byte character</returns>
	<remarks>Byte2String({83, 101, 101}, 0, 3) = "See"</remarks>
</member><member name="M:atcUtility.modString.StrRetRem(System.String@)">
	<summary>
 Divide a string into 2 portions at the position of the first comma or space
 Returns the portion before the delimiter and removes the first portion and the delimiter from the original string
 Does not search for comma or space in the part of a string between single quotes, and removes the single quotes
 Example: StrRetRem("Hello world") = "Hello", and S is reduced to "world"
 Example: StrRetRem("Hello,world") = "Hello", and S is reduced to "world"
 Example: StrRetRem("'Hello,world',fabulous") = "Hello,world", and S is reduced to "fabulous"
 Example: StrRetRem("Hello") = "Hello", and S is reduced to an empty string
 </summary>
	<param name="S">String to divide</param>
	<returns>Portion of incoming string from the start until the first comma or space</returns>
	<remarks>Returns the entire string if no comma or space is found.</remarks>
</member><member name="T:atcUtility.modString">
	<summary>
 General utility subroutines and functions shared by many projects
 </summary>
	<remarks>Mark Gray and Jack Kittle of AQUA TERRA CONSULTANTS 2003-2010
 Copyright 2010 AQUA TERRA Consultants - Royalty-free use permitted under open source license
 </remarks>
</member><member name="T:atcUtility.IatcTable">
	<summary>
	</summary>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTableOpener.OpenAnyTable(System.String)">
	<summary>
 opens a table for known table types based on file extension
 </summary>
	<param name="aFileName">name of file containing table</param>
	<returns>opened table if file exists and of known type</returns>
	<remarks></remarks>
</member><member name="T:atcUtility.atcTableOpener">
	<summary>
 opens a file containing a table based on the file extension
 </summary>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.Cousin">
	<summary>
 copies a table's structure without data
 </summary>
	<returns>new table with the same fields as this one, but no data</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.CreationCode">
	<summary>
 produces Visual Basic code needed to create this table
 </summary>
	<returns>VB source code to create this table</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.OpenFile(System.String)">
	<summary>
 Open the specified file, probably read at least the metadata about fields
 </summary>
	<param name="aFilename">name of file containing table</param>
	<returns>true if table opened successfully</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.WriteFile(System.String)">
	<summary>
 Write the current table to the specified file
 </summary>
	<param name="aFilename">name of file to write table to</param>
	<returns>true if table written successfully</returns>
	<remarks></remarks>
</member><member name="P:atcUtility.atcTable.Header(System.Int32)">
	<summary>
 Get a specified row of the header
 </summary>
	<param name="aHeaderRow">Which row to get (range is 1..NumHeaderRows)</param>
	<returns>text of specified row of the header</returns>
</member><member name="P:atcUtility.atcTable.Header">
	<summary>
 All rows of the header concatenated with cr/lf at the end of each line
 </summary>
</member><member name="P:atcUtility.atcTable.NumHeaderRows">
	<summary>
 The number of header rows in the table
 </summary>
	<value></value>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.TrimValue(System.String,System.String)">
	<summary>
 Trim leading and trailing spaces from value.
 If numeric, also trim trailing zeroes after decimal point and trailing decimal point
 </summary>
	<param name="aValue">Value to be trimmed</param>
	<param name="aType">Type character, N = Numeric</param>
</member><member name="M:atcUtility.atcTable.FieldNumber(System.String)">
	<summary>
 determine field number from field name
 </summary>
	<param name="aFieldName">name of specified field</param>
	<returns>the number of the field with the specified name or zero if the named field does not appear in this file</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.atcTable.FindMatch(System.Int32[],System.String[],System.Object[],System.Boolean,System.Int32,System.Int32)">
	<summary>
 Find a record matching a set of rules
 </summary>
	<param name="aFieldNum">array of fields to compare</param>
	<param name="aOperation">comparisons to make</param>
	<param name="aFieldVal">values to compare fields to</param>
	<param name="aMatchAny">true if any one comparison is enough to match, 
 default of false means all comparisons must be true to match a record</param>
	<param name="aStartRecord">record number to start searching</param>
	<param name="aEndRecord">record number to stop searching (default of -1 searches to end of table)</param>
	<returns>true if a matching record was found, with CurrentRecord set to the record that was found.
 false if no matching record was found, with CurrentRecord set to aStartRecord</returns>
</member><member name="M:atcUtility.atcTable.PopulateObjects(System.Type,atcUtility.atcCollection,System.Object[],System.Reflection.BindingFlags)">
	<summary>
 Create a new list of objects, one for each record of the table, populated from columns of table
 </summary>
	<param name="aObjectType"></param>
	<param name="aFieldMap">Mapping of table field names as keys to object field/property names as items</param>
	<param name="aNewArgs"></param>
	<param name="aNewBindingFlags"></param>
	<returns></returns>
	<remarks>If aFieldMap is Nothing, default mapping of exactly the same field names is attempted</remarks>
</member><member name="M:atcUtility.atcTable.PopulateObject(System.Object@,atcUtility.atcCollection)">
	<summary>
 Populate an object from the current record of the table
 </summary>
	<param name="aObject">Object to populate</param>
	<param name="aFieldMap">Mapping of table field names as keys to object field/property names as items</param>
	<remarks>If aFieldMap is Nothing, default mapping of exactly the same field names is attempted</remarks>
</member><member name="T:atcUtility.atcTable">
	<summary>
 generic table class
 </summary>
	<remarks></remarks>
</member><member name="T:atcUtility.atcTableArray">
	<summary>
 Manage a table of strings
 </summary>
	<remarks>
 Values are stored as a Generic.List(Of String()) where the Generic.List manages the rows and each row is an array of String
 </remarks>
</member><member name="M:atcUtility.atcCollection.BinarySearchForKey(System.String)">
	<summary>Returns first index of a key equal to or higher than aKey</summary>
	<param name="aKey">Key to search for</param>
	<returns>Returns aKeys.Count if aKeys is empty or contains only values less than aKey</returns>
	<remarks>Only works for collections sorted by key</remarks>
</member><member name="M:atcUtility.atcCollection.BinarySearchForKey(System.Double)">
	<summary>Returns first index of a key equal to or higher than aKey</summary>
	<param name="aKey">Key to search for</param>
	<returns>Returns aKeys.Count if aKeys is empty or contains only values less than aKey</returns>
	<remarks>Only works for collections sorted by key</remarks>
</member><member name="M:atcUtility.atcCollection.Add(atcUtility.atcCollection)">
	<summary>Add items from an atcCollection along with their keys</summary>
</member><member name="T:atcUtility.atcCollection.clsDictionaryEnumerator">
	<summary>
 Enumerator returns key/value pairs as DictionaryEntry objects
 </summary>
</member><member name="T:atcUtility.atcCollection">
	<summary>
 Collection that extends ArrayList with Keys
 </summary>
	<remarks>
 Copyright 2006 AQUA TERRA Consultants - Royalty-free use permitted under open source license
 </remarks>
</member><member name="M:atcUtility.PointLocations.GetKeyForItem(atcUtility.PointLocation)">
	<summary>Describes which property of PointLocation is the Key</summary>
	<param name="aPointLocation">PointLocation to determine key for</param>
	<returns>Key associated with aPointLocation argument</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.PointLocations.#ctor(System.String,System.String)">
	<summary>Opens specified table and fills locations</summary>
	<param name="aFileName">Name of containing table</param>
	<remarks>Existing external file in current directory used before internal default version of file</remarks>
</member><member name="M:atcUtility.PointLocations.AddLocation(atcUtility.atcTable)">
	<summary>Fill specific details about point from record in table</summary>
	<param name="aTable">table containing locations</param>
	<remarks>uses current record from table</remarks>
</member><member name="M:atcUtility.PointLocations.InternalFilename">
	<summary>Name of embedded file containing default locations</summary>
	<returns>filename without path</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.PointLocations.Delimeter">
	<summary>Delimter within records in table</summary>
	<returns>record field delimeter</returns>
	<remarks>may be different than original delimeter in table</remarks>
</member><member name="M:atcUtility.PointLocations.Closest(System.Double,System.Double,System.Int32)">
	<summary>Determines closest locations to specfied point</summary>
	<param name="aLatitude">Latitude in decimal degrees</param>
	<param name="aLongitude">Longitude in decimal degrees</param>
	<param name="aMaxCount">Maximum number of locations to return</param>
	<returns>Closest locations</returns>
	<remarks>Defauts to five closest locations</remarks>
</member><member name="T:atcUtility.PointLocations">
	<summary>Base class for a collection of locations</summary>
	<remarks></remarks>
</member><member name="F:atcUtility.PointLocation.Record">
	<summary>Table record associated with this point</summary>
</member><member name="F:atcUtility.PointLocation.Id">
	<summary>Identifier for record</summary>
</member><member name="F:atcUtility.PointLocation.Latitude">
	<summary>Latitude in decimal degrees</summary>
</member><member name="F:atcUtility.PointLocation.Longitude">
	<summary>Longitude in decimal degrees</summary>
</member><member name="M:atcUtility.PointLocation.#ctor">
	<summary>Default constructor</summary>
</member><member name="M:atcUtility.PointLocation.#ctor(atcUtility.atcTable,System.Int32,System.Int32,System.Int32,System.String)">
	<summary></summary>
	<param name="aPointTable"></param>
	<param name="aIdField"></param>
	<param name="aLatitudeField"></param>
	<param name="aLongitudeField"></param>
	<param name="aDelimeter"></param>
	<remarks></remarks>
</member><member name="M:atcUtility.PointLocation.Key">
	<summary>Key for location</summary>
</member><member name="M:atcUtility.PointLocation.Description">
	<summary>Location text details</summary>
</member><member name="M:atcUtility.PointLocation.ToString">
	<summary></summary>
	<returns>Description of location</returns>
</member><member name="T:atcUtility.PointLocation">
	<summary>Base class for a location</summary>
	<remarks>Contains minimum details</remarks>
</member><member name="M:atcUtility.Spatial.GreatCircleDistance(System.Double,System.Double,System.Double,System.Double)">
	<summary>Computes distance between two points</summary>
	<param name="aLong1">Longitude of first point</param>
	<param name="aLat1">Latitude of first point</param>
	<param name="aLong2">Longitude of second point</param>
	<param name="aLat2">Latitude of second point</param>
	<returns>Distance between points</returns>
	<remarks>Distance units are meters</remarks>
</member><member name="T:atcUtility.Spatial">
	<summary>Wrapper for distance calculations</summary>
</member><member name="M:atcUtility.atcMDB.#ctor(System.String)">
	<summary>
 Open an MDB file given its filename
 </summary>
	<param name="aFilename">Name of database file to open</param>
</member><member name="M:atcUtility.atcMDB.GetTable(System.String)">
	<summary>
 Open a table within the database
 </summary>
	<param name="aTableName">Name of a table</param>
	<returns>System.Data.DataTable</returns>
	<remarks>aTableName can be a query, "SELECT * from " will be prepended within GetTable</remarks>
</member><member name="T:atcUtility.atcMDB">
	<summary>
 Opens a MDB file and returns tables within it as DataTable
 </summary>
</member><member name="P:atcUtility.atcTableRDB.FieldType(System.Int32)">
	<summary>
 Overriding default FieldType to translate from RDB to DBF version of type character
 </summary>
	<param name="aFieldNumber"></param>
	<value></value>
	<returns></returns>
	<remarks>
 RDB s = string  -&gt; DBF C = Character
 RDB d = date    -&gt; DBF C = Character
 RDB n = numeric -&gt; DBF N = Numeric
 </remarks>
</member><member name="T:atcUtility.atcTableRDB">
	<summary>
 Read and write USGS RDB-formatted delimited text files as a table
 </summary>
	<remarks>
 Field delimiter is a tab
 Header rows start with #
 First row after headers is column labels
 Second row after headers contains field widths and types
 </remarks>
</member><member name="T:atcUtility.atcTableDelimited">
	<summary>
 Read and write delimited text files as a table
 </summary>
	<remarks>
 Default field delimiter is a comma
 First row after NumHeaderRows is read as field names
 </remarks>
</member><member name="P:atcUtility.atcTableFixed.FieldStart(System.Int32)">
	<summary>
 Character position where the field starts
 </summary>
	<param name="aFieldNumber">Number of field (one to NumFields)</param>
	<value></value>
	<returns>Character position &gt;= 1</returns>
	<remarks>Returns zero if field does not exist</remarks>
</member><member name="M:atcUtility.modFile.TryMove(System.String,System.String,System.Boolean)">
	<summary>
 Try moving a file to a new location, log a failure rather than raising an exception
 </summary>
	<param name="aFromFilename">Path of file to be moved</param>
	<param name="aToPath">Folder or full path to move to</param>
	<param name="aVerbose">True to log what happens with Logger.Dbg</param>
	<returns>True if successful, False if unsuccessful</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modFile.TryDeleteShapefile(System.String)">
	<summary>
 Delete a shape file (including all associated files: .shp, .shx, .dbf, .prj, .spx, .sbn, .xml, .shp.xml, .mwsr)
 </summary>
	<param name="aShapefilename">file name of shape file (must end with .shp)</param>
	<returns>True if all existing files were deleted or already did not exist, 
 False if any files were present which could not be deleted.</returns>
	<remarks>Most likely cause of failure is shape file is open (currently on a map)</remarks>
</member><member name="M:atcUtility.modFile.TryDeleteGroup(System.String,System.String[],System.Boolean)">
	<summary>
 Delete a group of files with the same base name and different extensions
 </summary>
	<param name="aBaseFilename">full path and file name of one file to delete (example: "C:\temp.shp")</param>
	<param name="aExtensions">all possible extensions to copy, examples are ShapeExtensions and TifExtensions above</param>
	<param name="aVerbose">True to log what happens with Logger.Dbg</param>
	<returns>True if all existing files were deleted or already did not exist, 
 False if any files were present which could not be deleted.</returns>
	<remarks>Most likely cause of failure is a file is open (for example is currently on a map)</remarks>
</member><member name="M:atcUtility.modFile.TryCopyShapefile(System.String,System.String)">
	<summary>
 Copy a shape file (including all associated files: .shp, .shx, .dbf, .prj, .spx, .sbn, .xml, .shp.xml, .mwsr)
 Log any exceptions and return false rather than raising them
 </summary>
	<param name="aShapeFilename">full path and file name of shape file to copy (example: "C:\temp.shp")</param>
	<param name="aDestinationPath">full path of destination folder or file name 
 (example: "C:\NewLocation\" or "C:\NewLocation\NewFilename.shp")</param>
	<returns>True if all existing files were copied, False if an existing file could not be copied.</returns>
</member><member name="M:atcUtility.modFile.TryCopyGroup(System.String,System.String,System.String[],System.Boolean)">
	<summary>
 Copy a group of files with the same base name and different extensions
 Log any exceptions and return false rather than raising them
 </summary>
	<param name="aBaseFilename">full path and file name of one file to copy (example: "C:\temp.shp")</param>
	<param name="aDestinationPath">full path of destination folder or file name 
 (example: "C:\NewLocation\" or "C:\NewLocation\NewFilename.shp")</param>
	<param name="aExtensions">all possible extensions to copy, examples are ShapeExtensions and TifExtensions above</param>
	<param name="aVerbose">True to log what happens with Logger.Dbg</param>
	<returns>True if all existing files were copied, False if an existing file could not be copied.</returns>
</member><member name="M:atcUtility.modFile.TryMoveShapefile(System.String,System.String)">
	<summary>
 Move a shape file (including all associated files: .shp, .shx, .dbf, .prj, .spx, .sbn, .xml, .shp.xml, .mwsr)
 Log any exceptions and return false rather than raising them
 </summary>
	<param name="aShapeFilename">full path and file name of shape file to move (example: "C:\temp.shp")</param>
	<param name="aDestinationPath">full path of destination folder or file name 
 (example: "C:\NewLocation\" or "C:\NewLocation\NewFilename.shp")</param>
	<returns>True if all existing files were moved, False if an existing file could not be moved.</returns>
</member><member name="M:atcUtility.modFile.TryMoveGroup(System.String,System.String,System.String[],System.Boolean)">
	<summary>
 Move a group of files with the same base name and different extensions
 Log any exceptions and return false rather than raising them
 </summary>
	<param name="aBaseFilename">full path and file name of shape file to move (example: "C:\temp.shp")</param>
	<param name="aDestinationPath">full path of destination folder or file name 
 (example: "C:\NewLocation\" or "C:\NewLocation\NewFilename.shp")</param>
	<param name="aExtensions">all possible extensions to copy, examples are ShapeExtensions and TifExtensions above</param>
	<param name="aVerbose">True to log what happens with Logger.Dbg</param>
	<returns>True if all existing files were moved, False if an existing file could not be moved.</returns>
</member><member name="M:atcUtility.modFile.GetTemporaryFileName(System.String,System.String)">
	<summary>
 Return a new file name with a given base file name and extension.
 If aBaseName is not a full path, the IO.Path.GetTempPath folder will be used
 An integer is inserted between the base file name and extension if needed to avoid conflict with an existing file.
 If aBaseName.aExtension already exists (as a file or folder), 
    aBaseName_1.aExtension is tried, then 
    aBaseName_2.aExtension, ..., until a file name is found for which the file does not yet exist
 Temporary files/folders found older than one day will be deleted and the name will be reused
 </summary>
	<remarks>It is the caller's responsibility to both create and remove this file. Two identical calls will get the same result if the file is not created before the second call.</remarks>
</member><member name="M:atcUtility.modFile.GetNewFileName(System.String,System.String)">
	<summary>
 Return a file name matching the given pattern which does not yet exist.
 If aBaseName.aExtension already exists (as a file or folder), 
    aBaseName_1.aExtension is tried, then 
    aBaseName_2.aExtension, ..., until a file name is found for which the file does not yet exist
 </summary>
	<remarks>It is the caller's responsibility to both create and remove this file. Two identical calls will get the same result if the file is not created before the second call.</remarks>
</member><member name="M:atcUtility.modFile.NewTempDir(System.String)">
	<summary>
 Create a new empty folder in the user's temporary folder. 
 </summary>
	<param name="aBaseName">String to start temporary folder name with.</param>
	<returns>
 The return value will be aBaseName if it does not yet exist, or will have 
 underscore and a number appended to avoid having the same name as an existing directory
 </returns>
	<remarks>It is the caller's responsibility to remove this folder and its contents later.</remarks>
</member><member name="M:atcUtility.modFile.ShowHelp(System.String)">
	<summary>
 Show Help for specified topic
 </summary>
	<param name="aHelpTopic">Topic to display</param>
	<remarks>if aHelpTopic is a file, set the file to display instead of opening help</remarks>
</member><member name="M:atcUtility.modFile.ChDriveDir(System.String)">
	<summary>
 Changes directory and, if necessary, drive. Returns True if successful.
 </summary>
	<param name="aPath">New pathname</param>
	<returns>True if directory change is successful</returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modFile.ConvertLongPathToShort(System.String)">
	<summary>
 Convert a long path name to a short path name
 </summary>
	<param name="aLongPathName">Long path name to convert</param>
	<returns>Converted short path name</returns>
	<remarks>Use this routine when length of file name is limited (like wdm names)</remarks>
</member><member name="T:atcUtility.modFile.clsLinesInFile">
	<summary>
 An enumerable set of lines read from a text file (or other BinaryReader)
 lines in file end with carriage return and/or linefeed
 end of line characters are stripped from enumerated lines returned
 </summary>
</member><member name="T:atcUtility.modFile.clsLinesInFileReadLine">
	<summary>
 An enumerable set of lines read from a text file (or other BinaryReader)
 lines in file end with carriage return and/or linefeed
 end of line characters are stripped from enumerated lines returned
 </summary>
</member><member name="M:atcUtility.modFile.NextLine(System.IO.BinaryReader)">
	<summary>
 Read the next line from a text file whose lines end with carriage return and/or linefeed
 </summary>
	<param name="aReader"></param>
	<returns></returns>
	<remarks></remarks>
</member><member name="M:atcUtility.modFile.GetNaN">
	<summary>
 Gets System.Double.NaN (not a number)
 </summary>
	<returns>Double.NaN</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to NaN</remarks>
</member><member name="M:atcUtility.modFile.GetNaNInternal(System.Double)">
	<summary>
 Magic - reference to System.Double.NaN in optional argument elimates problem
 </summary>
	<param name="aNaN"></param>
	<returns>Double.NaN</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to NaN</remarks>
</member><member name="M:atcUtility.modFile.GetMaxValue">
	<summary>
 Gets System.Double.MaxValue
 </summary>
	<returns>Double.MaxValue</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to Double.*</remarks>
</member><member name="M:atcUtility.modFile.GetMaxValueInternal(System.Double)">
	<summary>
 Magic - reference to System.Double.MaxValue in optional argument elimates problem
 </summary>
	<param name="aMaxValue"></param>
	<returns>Double.MaxValue</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to Double.*</remarks>
</member><member name="M:atcUtility.modFile.GetMinValue">
	<summary>
 Gets System.Double.MinValue
 </summary>
	<returns>Double.MinValue</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to Double.*</remarks>
</member><member name="M:atcUtility.modFile.GetMinValueInternal(System.Double)">
	<summary>
 Magic - reference to System.Double.MinValue in optional argument elimates problem
 </summary>
	<param name="aMinValue"></param>
	<returns>Double.MaxValue</returns>
	<remarks>workaround for mystery bug - program exit without message on first reference to Double.*</remarks>
</member><member name="M:atcUtility.modReflection.GetEmbeddedFileAsString(System.String,System.String)">
	<summary>
 Extracts an embedded file out of a given assembly as a string
 </summary>
	<param name="fileName">Name of the file to extract.</param>
	<returns>A string containing the file data.</returns>
</member><member name="M:atcUtility.modReflection.GetEmbeddedFileAsString(System.String,System.Reflection.Assembly)">
	<summary>
 Extracts an embedded file out of a given assembly as a string
 </summary>
	<param name="aAssembly">Assembly file is embedded in.</param>
	<param name="fileName">Name of the file to extract.</param>
	<returns>A string containing the file data.</returns>
</member><member name="M:atcUtility.modReflection.SetSomething(System.Object@,System.String,System.Object)">
	<summary>
 Set a property or field given its name and a new value
 </summary>
	<param name="aObject">Object whose property or field needs to be set</param>
	<param name="aFieldName">Name of property or field to set</param>
	<param name="aValue">New value to set</param>
</member><member name="M:atcUtility.modReflection.SetSomething(System.Object@,System.String,System.Object,System.Boolean)">
	<summary>
 Set a property or field given its name and a new value
 </summary>
	<param name="aObject">Object whose property or field needs to be set</param>
	<param name="aFieldName">Name of property or field to set</param>
	<param name="aValue">New value to set</param>
	<param name="aLogProblems">Quiet flag</param>
</member><member name="M:atcUtility.modReflection.CopyControlState(System.Windows.Forms.Control,System.Windows.Forms.Control)">
	<summary>
 Copy the Text or Checked state from one Windows.Forms.Control to another
 Also copies state of child controls, if any
 </summary>
	<param name="aOriginalControl">Control to copy state from</param>
	<param name="aCopyTo">Control to copy state to</param>
	<remarks>Useful for copying the state of an Options form to support Cancel</remarks>
</member><member name="T:atcUtility.modReflection">
	<summary>Convenience functions wrapping System.Reflection </summary>
	<remarks>Copyright 2005 AQUA TERRA Consultants - Royalty-free use permitted under open source license</remarks>
</member>
</members>
</doc>